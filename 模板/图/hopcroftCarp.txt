hopcroftCarp#include<iostream>#include<cstdio>#include<cstring>#include<algorithm>#include<map>#include<vector>#include<set>#include<queue>#define ll long long#define INF 0x3fffffff using namespace std;const int MAXN=40005;const int N=500000;int n;vector<int> G[MAXN];int Mx[MAXN],My[MAXN];int dx[MAXN],dy[MAXN];int dis;bool used[MAXN];void init(){	for(int i=0;i<=n;i++)	{		G[i].clear();			}}bool searchp(){	queue<int> q;	dis=INF;	memset(dx,-1,sizeof dx);	memset(dy,-1,sizeof dy);	for(int i=0;i<n;i++)	{		if(Mx[i]==-1)		{			q.push(i);			dx[i]=0;		}	}	while(!q.empty())	{		int u=q.front();		q.pop();		if(dx[u]>dis)		break;		int l=G[u].size();		for(int i=0;i<l;i++)		{			int to=G[u][i];			if(dy[to]==-1)			{				dy[to]=dx[u]+1;				if(My[to]==-1)				 dis=dy[to];				 else				 {				 	dx[My[to]]=dy[to]+1;				 	q.push(My[to]);				 }			}		}	}	return dis!=INF;}bool dfs(int u){	int len=G[u].size();	for(int i=0;i<len;i++)	{		int to=G[u][i];		if(!used[to]&&dy[to]==dx[u]+1)		{			used[to]=true;			if(My[to]!=-1&&dy[to]==dis)			continue;			if(My[to]==-1||dfs(My[to]))			{				My[to]=u;				Mx[u]=to;				return true;			}		}	}	return false;}int getMax(){	int ans=0;	memset(Mx,-1,sizeof Mx);	memset(My,-1,sizeof My);	while(searchp())	{		memset(used,false,sizeof used);		for(int i=0;i<n;i++)		{			if(Mx[i]==-1&&dfs(i))			  ans++;		}	}	return ans;}int main(){		int T; int kk=0;	scanf("%d",&T);	while(T--)	{  	    init();	    int ans=getMax();	}	return 0;}                                                                                                                    